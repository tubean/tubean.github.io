<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bean&#39;s blog</title>
    <link>https://tubean.github.io/</link>
    <description>Recent content on Bean&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>vi</language>
    <lastBuildDate>Tue, 07 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tubean.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Daily Coding Problem] #11</title>
      <link>https://tubean.github.io/2020/04/daily-code-11/</link>
      <pubDate>Tue, 07 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-11/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  There exists a staircase with N steps, and you can climb up either 1 or 2 steps at a time. Given N, write a function that returns the number of unique ways you can climb the staircase. The order of the steps matters.
For example, if N is 4, then there are 5 unique ways:
 1, 1, 1, 1 2, 1, 1 1, 2, 1 1, 1, 2 2, 2  What if, instead of being able to climb 1 or 2 steps at a time, you could climb any number from a set of positive integers X?</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #10</title>
      <link>https://tubean.github.io/2020/04/daily-code-10/</link>
      <pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-10/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  Implement an autocomplete system. That is, given a query string s and a set of all possible query strings, return all strings in the set that have s as a prefix.
For example, given the query string de and the set of strings [dog, deer, deal], return [deer, deal].
Hint: Try preprocessing the dictionary into a more efficient data structure to speed up queries.</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #9</title>
      <link>https://tubean.github.io/2020/04/daily-code-9/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-9/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  Implement a job scheduler which takes in a function f and an integer n, and calls f after n milliseconds.
 Code public class Main { public static void main(String[] args) { solution(() -&amp;gt; System.out.println(&amp;quot;Hello World&amp;quot;), 10000); } public static void solution(Command command, int n) { new Timer().schedule(new TimerTask() { @Override public void run() { command.execute(); } }, n); } interface Command { void execute(); } }  Source code https://github.</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #8</title>
      <link>https://tubean.github.io/2020/04/daily-code-8/</link>
      <pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-8/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  Given a list of integers, write a function that returns the largest sum of non-adjacent numbers. Numbers can be 0 or negative.
For example, [2, 4, 6, 2, 5] should return 13, since we pick 2, 6, and 5. [5, 1, 1, 5] should return 10, since we pick 5 and 5. Follow-up: Can you do this in O(N) time and constant space?</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #7</title>
      <link>https://tubean.github.io/2020/04/daily-code-7/</link>
      <pubDate>Fri, 03 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-7/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  A unival tree (which stands for &amp;ldquo;universal value&amp;rdquo;) is a tree where all nodes under it have the same value.
Given the root to a binary tree, count the number of unival subtrees.
For example, the following tree has 5 unival subtrees:
 0 / \ 1 0 / \ 1 0 / \ 1 1   Code implementation private static int getUnivalCount(TreeNode node){ if (node == null)return 0; int count = getUnivalCount(node.</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #6</title>
      <link>https://tubean.github.io/2020/04/daily-code-6/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-6/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  This problem was asked by Facebook.
Given the mapping a = 1, b = 2, &amp;hellip; z = 26, and an encoded message, count the number of ways it can be decoded.
For example, the message &amp;lsquo;111&amp;rsquo; would give 3, since it could be decoded as &amp;lsquo;aaa&amp;rsquo;, &amp;lsquo;ka&amp;rsquo;, and &amp;lsquo;ak&amp;rsquo;.
You can assume that the messages are decodable. For example, &amp;lsquo;001&amp;rsquo; is not allowed.</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #5</title>
      <link>https://tubean.github.io/2020/04/daily-code-5/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/04/daily-code-5/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  This problem was asked by Google.
An XOR linked list is a more memory efficient doubly linked list. Instead of each node holding next and prev fields, it holds a field named both, which is an XOR of the next node and the previous node. Implement an XOR linked list; it has an add(element) which adds the element to the end, and a get(index) which returns the node at index.</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #4</title>
      <link>https://tubean.github.io/2020/03/daily-code-4/</link>
      <pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/03/daily-code-4/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay như sau:
Problem  Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well.
For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #3</title>
      <link>https://tubean.github.io/2020/03/daily-code-3/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/03/daily-code-3/</guid>
      <description>Chào các bạn.
Câu hỏi hôm nay là về kiểu cấu trúc dữ liệu dạng cây:
Problem  Given the root to a binary tree, implement serialize(root), which serializes the tree into a string, and deserialize(s), which deserializes the string back into the tree.
 For example, given the following Node class
class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right  The following test should pass:</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #2</title>
      <link>https://tubean.github.io/2020/03/daily-code-2/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/03/daily-code-2/</guid>
      <description>Chào các bạn.
Ngày hôm nay chúng ta sẽ xem xét một câu hỏi của Uber:
Problem  Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.
For example, if our input was [1, 2, 3, 4, 5], the expected output would be [120, 60, 40, 30, 24].</description>
    </item>
    
    <item>
      <title>[Daily Coding Problem] #1</title>
      <link>https://tubean.github.io/2020/03/daily-code-1/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2020/03/daily-code-1/</guid>
      <description>Chào các bạn.
Nhân dịp rảnh rỗi do dịch COVID-19, tôi quyết định đào mộ lại cái blog này sau một năm bận các công việc cá nhân.
Như tiêu đề thì series này sẽ tổng hợp một số câu hỏi phỏng vấn về thuật toán kinh điển trong các công ty cũng như cách giải quyết vấn đề cho mỗi câu hỏi. Mọi bài toán đều có cách giải riêng cho nó.</description>
    </item>
    
    <item>
      <title>[Microservice] Các khái niệm chính trong microservice</title>
      <link>https://tubean.github.io/2018/12/microservice-key-architectural-concepts/</link>
      <pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/microservice-key-architectural-concepts/</guid>
      <description>Trong bài viết này, chúng ta sẽ tìm hiểu một số khái niệm chính trong hệ thống microservice.
1. Monolithic Architecture Các ứng dụng doanh nghiệp ngày nay đang được thiết kế để đáp ứng được số lượng lớn nghiệp vụ kinh doanh. Do đó một ứng dụng phần mềm cần cung cấp hàng trăm chức năng và tất cả các những chức năng như vậy thường được gói gọn trong một ứng dụng nguyên khối duy nhất.</description>
    </item>
    
    <item>
      <title>[Microservice] Dựng Microservice web bằng Spring Boot và Eureka [Phần 3]</title>
      <link>https://tubean.github.io/2018/12/microservice-springboot-eureka-part3/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/microservice-springboot-eureka-part3/</guid>
      <description>Ở bài viết trước, chúng ta đã dựng được một hệ thống microservice đơn giản với 2 microservice, 1 cổng gateway và 1 naming server và thực hiện xác thực người dùng bằng JWT. Trong bài viết lần này chúng ta sẽ tìm hiểu cách xử lý lỗi và ghi log trong hệ thống microservice theo thiết kế Circuit Breaker và Log Tracing.
1. Hystrix Giả sử bạn có 3 service: A, B và C.</description>
    </item>
    
    <item>
      <title>[Microservice] Dựng Microservice web bằng Spring Boot và Eureka [Phần 2]</title>
      <link>https://tubean.github.io/2018/12/microservice-springboot-eureka-part2/</link>
      <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/microservice-springboot-eureka-part2/</guid>
      <description>Ở bài viết trước, chúng ta đã dựng được một hệ thống microservice đơn giản với 2 microservice, 1 cổng gateway và 1 naming server. Trong bài viết này, chúng ta sẽ tìm hiểu cách xác thực đối với hệ thống microservice bằng JWT.
1. Authentication Workflow Chúng ta sẽ xem xét những bước xác thực diễn ra như thế nào trong một hệ thống bình thường:
 Người dùng gửi một request để lấy một token thông qua một hệ thống đăng nhập.</description>
    </item>
    
    <item>
      <title>[Microservice] Dựng Microservice web bằng Spring Boot và Eureka [Phần 1]</title>
      <link>https://tubean.github.io/2018/12/microservice-springboot-eureka/</link>
      <pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/microservice-springboot-eureka/</guid>
      <description>Microservices là một giải pháp cho phép chia một hệ thống lớn thành một vài các component độc lập về phát triển, test và deploy.
Spring Cloud là một dự án con trong họ nhà Spring, được sử dụng để phát triển các ứng dụng phân tán. Một ứng dụng được gọi là phần tán (Distributed application) khi các phần của nó có thể được phát triển trên các ngôn ngữ khác nhau và được triển khai trên các máy chủ khác nhau.</description>
    </item>
    
    <item>
      <title>[Web architecture] Kiến trúc monolithic và microservice</title>
      <link>https://tubean.github.io/2018/12/monolithic-vs-microservice/</link>
      <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/monolithic-vs-microservice/</guid>
      <description>Trong lập trình web hiện nay, hai loại kiến trúc web mà chúng ta thường áp dụng cho ứng dụng của mình là kiến trúc một khối (Monolithic architecture) và kiến trúc microservice (Microservice architecture). Trong bài viết này, chúng ta sẽ tìm hiểu về hai loại kiến trúc này để biết ưu nhược điểm cũng như khi nào sử dụng chúng.
1. Kiến trúc một khối (Monolithic web architecture) Kiến trúc một khối là mẫu thiết kế được dùng nhiều nhất trong giới lập trình web hiện nay bởi tính đơn giản của nó khi phát triển và khi deploy.</description>
    </item>
    
    <item>
      <title>[Design Pattern] Prototype Design Pattern</title>
      <link>https://tubean.github.io/2018/12/prototype-pattern/</link>
      <pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/prototype-pattern/</guid>
      <description>Trong lập trình hướng đối tượng, khi chúng ta muốn tạo thêm một đối tượng thì thường sử dụng từ khóa new. Tuy nhiên đối với cách tạo đối tượng này thì những thuộc tính ban đầu sẽ thường là trống, trừ khi được khởi tạo giá trị default hoặc khởi tạo ngay trong contructor. Vậy nếu chúng ta muốn tạo mới một đối tượng từ một đối tượng cũ, mang tất cả thuộc tính và giá trị đang có của đối tượng cũ như một bản clone thì làm thế nào?</description>
    </item>
    
    <item>
      <title>[Spring Boot] Dựng app CRUD đơn giản bằng Spring Boot &#43; MongoDB trên Intelij</title>
      <link>https://tubean.github.io/2018/12/spring-boot-mongo-db/</link>
      <pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/spring-boot-mongo-db/</guid>
      <description>MongoDB hiện đang là cơ sở dữ liệu NoSQL phổ biến nhất. Bài viết này là một hướng dẫn nhỏ về cách sử dụng Spring Boot kết hợp với MongoDB để tạo một app dạng CRUD.
Các tool sử dụng:  Java Spring Boot Maven MongoDB Postman  1. Tạo database Trước khi bắt đầu xây dựng app, chúng ta cần chuẩn bị một instance của MongoDB để truy xuất tới nó.</description>
    </item>
    
    <item>
      <title>[Web Service] Sự khác nhau giữa SOAP và RESTful Web Service trong Java</title>
      <link>https://tubean.github.io/2018/12/web-service-s%E1%BB%B1-kh%C3%A1c-nhau-gi%E1%BB%AFa-soap-v%C3%A0-restful-web-service-trong-java/</link>
      <pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/web-service-s%E1%BB%B1-kh%C3%A1c-nhau-gi%E1%BB%AFa-soap-v%C3%A0-restful-web-service-trong-java/</guid>
      <description>Cả 2 loại SOAP và RESTful đều cho phép phía client gửi request đến server để query, nhưng chúng được thực hiện bằng những cách khác nhau. Sự khác nhau chính giữa SOAP và REST là cách mà client giao tiếp server thông qua SOAP sẽ bị hạn chế bởi nhiều quy tắc và format được thiết kế chính xác, trong khi với REST cho phép việc giao tiếp thông qua giao thức HTTP và ít các quy tắc rườm rà hơn.</description>
    </item>
    
    <item>
      <title>[Functional Programming]  Java Functional Composition</title>
      <link>https://tubean.github.io/2018/12/java-functional-composition/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/java-functional-composition/</guid>
      <description>Function composition là một khái niệm về việc nhiều function có thể lồng nhau để làm param của một function khác. Bạn có thể tự compose nhiều function (dùng Lambda Expression) vào trong một function của riêng bạn, nhưng Java cũng cung cấp những cách compose riêng giúp bạn làm việc đó dễ hơn. Trong bài viết này chúng ta cùng tìm hiểu làm thế nào để compose các function bằng các feature có sẵn của Java.</description>
    </item>
    
    <item>
      <title>[Functional Programming] Java Higher Order Functions</title>
      <link>https://tubean.github.io/2018/12/java-higher-order-function/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/java-higher-order-function/</guid>
      <description>Một higher order function là một function nhận một function (method) khác làm parameter, hoặc nó có kết quả trả về là một function. Bài viết này sẽ giới thiệu một vài ví dụ về higher order function.
1. Sorting Collections Ví dụ đầu tiên về higher order function là method Collections.sort() nhận một Comparator như một tham số:
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); list.add(&amp;quot;One&amp;quot;); list.add(&amp;quot;Abc&amp;quot;); list.add(&amp;quot;BCD&amp;quot;); Collections.sort(list, (String a, String b) -&amp;gt; { return a.</description>
    </item>
    
    <item>
      <title>[Design Pattern] Singleton Design Pattern</title>
      <link>https://tubean.github.io/2018/12/singleton-pattern/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/singleton-pattern/</guid>
      <description>1. Singleton là gì? Đã khi nào bạn viết một class mà chỉ muốn nó chỉ có duy nhất một instance? Trong lập trình, chúng ta sẽ đôi lần thấy rằng một số class chỉ nên có duy nhất một instance, vì nếu có nhiều hơn một, chúng ta sẽ gặp phải một vài vấn đề như hành vi chương trình không chính xác, lãng phí tài nguyên hay kết quả không nhất quán.</description>
    </item>
    
    <item>
      <title>[Functional Programming]  Functional Programing trong Java</title>
      <link>https://tubean.github.io/2018/12/java-functional-programming/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/java-functional-programming/</guid>
      <description>1. Functional Programming là gì? Functional Programming hay lập trình chức năng là kiểu lập trình mà function được chọn làm đơn vị thao tác cơ bản. Functional programming tập trung vào sử dụng tính năng của các hàm và tránh sử dụng các biến cũng như thay đổi giá trị của chúng. Nó hơi ngược với procedure programming như chúng ta vẫn thường sử dụng (OOP tập trung vào chi tiết hoạt động của chương trình và thường sử dụng các biến và thay đổi trạng thái của chương trình).</description>
    </item>
    
    <item>
      <title>[Design Pattern] Composite Design Pattern</title>
      <link>https://tubean.github.io/2018/12/composite-pattern/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/composite-pattern/</guid>
      <description>Trong bài viết này, chúng ta sẽ đi tìm hiểu về một mẫu thiết kế khá thú vị, đó là Composite pattern. Trong tiếng anh thì từ composite có nghĩa là làm một hỗn hợp, tức là một thứ gì đó được tạo từ rất nhiều thành phần hỗn tạp. Đây là một mẫu thiết kế thuộc nhóm cấu trúc. Một đối tượng composite được tạo thành từ một hay nhiều đối tượng tương tự nhau (hoặc có một số chức năng tương tự nhau).</description>
    </item>
    
    <item>
      <title>[Java] Unit Test với JUnit 5x</title>
      <link>https://tubean.github.io/2018/12/junix-5x/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/12/junix-5x/</guid>
      <description>Phiên bản hiện tại của JUnit là JUnit 5 và nó bao gồm các component khác nhau:
 JUnit Platform: layer nền tảng cho phép những testing framework có thể chạy trên máy ảo JVM. JUnit Jupiter: đây chính là phiên bản JUnit 5 và được chạy trên JUnit Platform. JUnit Vintage: kế thừa từ TestEngine và cho phép chạy các phiên bản cũ hơn của JUnit.  1. Cài đặt bằng Gradle buildscript { repositories { mavenCentral() // The following is only necessary if you want to use SNAPSHOT releases.</description>
    </item>
    
    <item>
      <title>[Java] Unit Test với JUnit 4x</title>
      <link>https://tubean.github.io/2018/11/junix-4x/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/junix-4x/</guid>
      <description>Trong bài viết này chúng ta cùng tìm hiểu về test và unit test bằng JUnit 4.x.
1. Một số thuật ngữ trong kiểm thử (testing) 1.1 Code under test Những đoạn code được kiểm thử thường gọi code under test. Nếu bạn đang kiểm thử một ứng dụng nào đó thì nó được gọi là application under test.
1.2 Test fixture Đây là các điều kiện để có thể bắt đầu kiểm thử.</description>
    </item>
    
    <item>
      <title>[Design Patterns] Facade Design Pattern in Java</title>
      <link>https://tubean.github.io/2018/11/facade-design-patterns/</link>
      <pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/facade-design-patterns/</guid>
      <description>Trong bài viết này, chúng ta cùng xem xét mẫu thiết kế khác, đó là Facade pattern. Trước khi đi vào chi tiết mẫu thiết kế, chúng ta cùng xem xét câu chuyện sau:
Công ty phần mềm A vận hành một sản phẩm tên là Schedule Server. Đó là một ứng dụng làm rất nhiều việc như gửi mail, sms, đọc và viết file đến địa chỉ đích, gửi và nhận file giữa 2 server.</description>
    </item>
    
    <item>
      <title>[Java] Thao tác với Excel file bằng Apache POI</title>
      <link>https://tubean.github.io/2018/11/excel-file-with-poi/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/excel-file-with-poi/</guid>
      <description>1- Apache POI là gì? Khi lập trình với bất cứ hệ thống nào thì việc thao tác với các file excel luôn là điều bắt buộc mọi developer phải nắm được. Và để làm việc hiệu quả với excel file trong java thì tôi xin giới thiệu thư viện Apache POI trong bài viết này. POI là viết tắt của Poor Obfuscation Implementation, đó là một thư viện mã nguồn mở của Java, được cung cấp bởi Apache giúp chúng ta làm việc với các tài liệu của Microsoft như Word, Excel, PowerPoint&amp;hellip;</description>
    </item>
    
    <item>
      <title>[Design Patterns] Adapter Design Pattern in Java</title>
      <link>https://tubean.github.io/2018/11/adapter-design-patterns/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/adapter-design-patterns/</guid>
      <description>Chuyện kể rằng bạn Bean là một developer và đang phát triển một website e-commerce. Trang web này cho phép người dùng mua và thanh toán online bằng cách dùng một cổng thanh toán của bên thứ 3. Mọi thứ đều nhẹ nhàng như cân đường hộp sữa, cho đến một ngày mưa gió bão bùng&amp;hellip; Vào cái ngày định mệnh ấy, PM của bạn Bean thông báo rằng sắp tới website sẽ thay đổi cổng thanh toán và bạn Bean sẽ phải chuẩn bị cho thay đổi này.</description>
    </item>
    
    <item>
      <title>[Magical Java] Tại sao 1000 == 1000 là sai, nhưng 100 == 100 lại đúng?</title>
      <link>https://tubean.github.io/2018/11/magical-1000-vs-100/</link>
      <pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/magical-1000-vs-100/</guid>
      <description>Cùng xem đoạn code sau và dự đoán kết quá:
Integer a = 1000, b = 1000; System.out.println(a == b);//1 Integer c = 100, d = 100; System.out.println(c == d);//2  Nếu các bạn đưa ra đáp án là false, false thì xin chúc mừng, các bạn nắm lý thuyết rất tốt. Ở đây chúng ta đang so sánh 2 object với nhau, và khi dùng toán tử &amp;ldquo;==&amp;rdquo; thì kết quả sẽ trả về false nếu 2 tham chiếu không cùng trỏ đến cùng một đối tượng.</description>
    </item>
    
    <item>
      <title>[Spring Boot] Dựng app CRUD đơn giản bằng Spring Boot &#43; Thymeleaf trên Intelij</title>
      <link>https://tubean.github.io/2018/11/spring-boot-crud-app/</link>
      <pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/spring-boot-crud-app/</guid>
      <description>Để remind kiến thức cũng như tổng kết khi mới bắt đầu học một công nghệ mới, mình thường tạo một app đơn giản có đủ các thao tác thêm, xóa, sửa (CRUD). Bài viết này là một tutorial dạng cơ bản nhất khi học về Spring, sử dụng các công nghệ sau:
 Spring Boot: để khởi tạo và cấu hình ứng dụng một cách nhanh chóng. Spring MVC: để xây dựng app.</description>
    </item>
    
    <item>
      <title>[Java 8] Stream trong Java 8 (Phần 2)</title>
      <link>https://tubean.github.io/2018/11/java-stream-part2/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/java-stream-part2/</guid>
      <description>Tiếp theo bài viết trước, bài viết này sẽ đi vào tìm hiểu cách sử dụng Stream trong Java.
1. Tạo một stream Có nhiều cách tạo một stream instance từ các source khác nhau. Mỗi khi được tạo thì instance sẽ không làm thay đổi source cũ, vì vậy chúng ta có thể thoải mái tạo nhiều instance stream khác nhau từ một source.
 Stream rỗng (Empty stream)  Khi muốn tạo một stream rỗng, ta dùng method empty():</description>
    </item>
    
    <item>
      <title>[Java 8] Stream trong Java 8 (Phần 1)</title>
      <link>https://tubean.github.io/2018/11/java-stream/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/java-stream/</guid>
      <description>Lambda expression kể từ trở thành một phần của Java thì đã làm thay đổi đáng kể thói quen sử dụng các Collection như chúng ta đã từng dùng ở các phiên bản trước Java 8. Mặc dù có thể xây dựng lại một bộ API Collections thay thế, nhưng nó sẽ ảnh hưởng rất lớn đến toàn bộ hệ sinh thái Java. Vì vậy mà những nhà phát triển Java đã có một chiến lược tốt hơn, đó là thêm các phương thức mở rộng vào các interface có sẵn (như là Collection, List, Iterable,&amp;hellip;) cùng các lớp abstraction như Stream để thực hiện các phép toán tổng hợp trên tập dữ liệu, cung cấp thêm cho các lớp hiện có các phương thức để có thể làm việc với Stream mà không ảnh hưởng với các cách làm việc cũ.</description>
    </item>
    
    <item>
      <title>[Java 8] Lambda Expression trong Java 8</title>
      <link>https://tubean.github.io/2018/11/java-lambda-expression/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/java-lambda-expression/</guid>
      <description>1. Lambda expresstion là gì? Lambda expression là một feature mới và nổi bật nhất của java 8 giúp số lượng code được giảm và là bước đầu khiến Java bước vào thế giới functional programming. Một lamba expression là một function được tạo mà không thuộc bất kì một class nào. Nó là một hàm không tên (unamed function) với các tham số (parameters) và phần body chứa khối lệnh được tách biệt với các tham số bằng dấu -&amp;gt;.</description>
    </item>
    
    <item>
      <title>[Spring Boot] Secu thập chưởng bảo vệ app Spring Boot của bạn</title>
      <link>https://tubean.github.io/2018/11/spring-boot-10-ways-security/</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/spring-boot-10-ways-security/</guid>
      <description>Spring Boot được release lần đầu năm 2014 và không có nhiều thay đổi đáng kể cho đến hiện tại. Với mục tiêu tự động cấu hình và giảm thiểu lượng code để có thể start một ứng dụng, Spring Boot đã giúp cho không biết con dân nhà Spring dễ sống và bớt chửi thề đi. Giống như khi dùng bất kì một framework nào để xây dựng ứng dụng, điều bạn cần quan tâm không chỉ là chất lượng code, vượt qua các test case, &amp;hellip; mà còn là khả năng bảo mật của ứng dụng.</description>
    </item>
    
    <item>
      <title>[Hugo] Hướng dẫn xây dựng blog cá nhân bằng Hugo &#43; Github</title>
      <link>https://tubean.github.io/2018/11/blog-with-hugo/</link>
      <pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/11/blog-with-hugo/</guid>
      <description>Bên cạnh các dịch vụ support người dùng tạo các trang blog cá nhân như blogger, wordpress,&amp;hellip; thì các dịch vụ hosting như github, bitbucket,&amp;hellip; cũng đã cho phép chúng ta xây dựng các trang blog trên chính tên miền của họ. Phổ biến hiện nay là các trang miền github.io được xây dựng trên nền tảng Jekyll. Tuy nhiên Jekyll không phải là duy nhất và cũng có những nhược điểm của riêng nó.</description>
    </item>
    
    <item>
      <title>Hello</title>
      <link>https://tubean.github.io/2018/10/hello/</link>
      <pubDate>Wed, 31 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://tubean.github.io/2018/10/hello/</guid>
      <description>&lt;p&gt;Để chào mừng bài post đầu tiên, một phút quốc ca bắt đầu!
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>